{"articles":[{"name":"First","description":"Marked - Markdown Parser\n========================\n\n[Marked] lets you convert [Markdown] into HTML.  Markdown is a simple text format whose goal is to be very easy to read and write, even when not converted to HTML.  This demo page will let you type anything you like and see how it gets converted.  Live.  No more waiting around.\n\nHow To Use The Demo\n-------------------\n\n1. Type in stuff on the left.\n2. See the live updates on the right.\n\nThat's it.  Pretty simple.  There's also a drop-down option in the upper right to switch between various views:\n\nWhy Markdown?\n-------------\n\nIt's easy.  It's not overly bloated, unlike HTML.  Also, as the creator of [markdown] says.\n\nReady to start writing?sss\n\n[Marked]: https://github.com/markedjs/marked/\n[Markdown]: http://daringfireball.net/projects/markdown/\n","id":"1"},{"name":"dd","description":"# AI Engineer\n\nAplicația făcută are rolul de a asista medicii în investigațiile medicale.\n\n## Cum se utilizează\n\nAplicația are suport la momentul de față doar pentru comanda 'optimise', care optimizează segmentările inițiale pentru imaginile unor investigații CT abdominale. După rularea și compilarea aplicației, se va introduce cuvântul 'optimise' de la tastatură, apoi numele fișierelor din care se va face citirea.\nCele două fișiere de input reprezinta valorile Hounsfield ale scanării, și segmentarea inițială.\nUn exemplu pentru input ar fi în felul următor:\n\n```\nComanda: optimise\nFisier de intrare hu: input/107-hu.in\nFisier de intrare seg: input/107-seg.in\n```\n\nRezultatul va fi scirs în fișierul 'optimise.out', în folderul în care se află aplicația.\n\n## Cum funcționează\n\nInițial, programul citește cele două fișiere de intrare. Acesta salvează într-o matrice valorile Hounsfield pentru fiecare pixel, și într-un vector granițele segmentării inițiale. Acest lucru se face în funcția 'read'.\n\nSe crează o matrice 'res', matricea care se va afișa. Aceasta are valoarea '1' acolo unde este organul pe care dorim să îl vedem, și '0' unde nu. Apoi, se generează o medie a valorilor din interiorul delimitării inițiale, pentru a observa ce valori corespund organului în cauză. În matricea de valori se vor căuta numerele între medie minusmarja de eroare și media plus 4*marja de eroare. By default, această marja de eroare este setată la 15, dar se poate modifica în funcție de particularitățile scanărilor. Se iau în considerare doar numerele care sunt la o distanță de câțiva pixeli de segmentarea inițială. Funcția 'detect' se ocupă de acest lucru.\n\nPentru a obține o imagine finală compactă și cât mai reprezentativă, se va folosi funcția 'adjust'. Aici, mai întâi se găsește centrul delimitării organului, și se va folosi o adaptare a algoritmului lui Lee pentru a se elimina toate părțile care nu fac parte din organ. Apoi se va folosi încă o dată algoritmul lui Lee pentru a elimina eventualele valori de '0' care apar în reprezentarea organului. Pentru a fi și mai exact, se rotunjesc marginile și colțurile.\n\nLa final, funcția 'write' scrie în fișierul 'optimise.out' matricea rezultată.\n\n## Cum se poate modifica\n\nSe poate modifica stringul 'path' pentru a indică path-ul de unde sunt luate fișierele de intrare și unde este pus cel de ieșire.\n\nSe poate modifica variabila 'errormrg' pentru a modifica marja de eroare despre care s-a vorbit mai sus.\n\nSe pot adăuga noi comenzi ușor, prin codarea de noi funcții.\n\n# Cum am ajuns la aceasta solutie\n\nMai întâi, am încercat să delimitez granița organului cu ajutorul diferențelor între două valori consecutive, excluzând valorile pentru aer. Totuși, nu a mers prea bine așa, și am încercat metoda de mai sus. Cred că metoda funcționează în regulă, deși mai are nevoie de multe pentru a genera o imagine perfectă. Complexitatea de timp este O(n<sup>2</sup>).\n","id":"2"}]}